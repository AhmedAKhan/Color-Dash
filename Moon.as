package {		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Shape;	import flash.display.GradientType;	import flash.geom.Matrix;	import fl.motion.Color;	import flash.geom.Rectangle;		public class Moon extends Bitmap {				public static const OCTS = 4;				public function Moon(size:uint) {			// Make the bitmapData match the size passed in			bitmapData = new BitmapData(size,size);			// Draw some perlin noise (for a change)			bitmapData.perlinNoise(size/2,size/2, OCTS, Math.random()*1000,true,true,1,true);			// Tint the bitmap data			var tint:Color = new Color();			tint.setTint(0xFFFFFF, 0.6); // 60% to white			bitmapData.colorTransform(new Rectangle(0,0,size,size), tint);			blendMode="add"; // Optional blend mode change			// Make a Shape object to draw the gradient in			var alphaMask:Shape = new Shape();			// Set up the required elements of a gradient			var colours = [ 0xFFFFFF, 0xFFFFFF ]; // White to white			var alphas = [ 1, 0 ]; // Fully opaque to fully transparent			var ratios = [ 200, 255 ]; // About 4/5 start point, fade out from there			var matrix:Matrix = new Matrix(); // Make a Matrix for the gradient			// Tell the Matrix to make a gradient box the full size of the moon			matrix.createGradientBox(size,size); // Rotation is unnecessary			// Draw the radial gradient to the alphaMask's graphics			alphaMask.graphics.beginGradientFill(GradientType.RADIAL, colours, alphas, ratios, matrix);			// Draw a rectangle shape so all pixels of the BitmapData are covered			// Drawing a circle or ellipse would result in opaque corners of the moon			alphaMask.graphics.drawRect(0,0,size,size);			alphaMask.graphics.endFill();			// draw the alphaMask to the BitmapData			bitmapData.draw(alphaMask, null, null, "alpha");		}	}}